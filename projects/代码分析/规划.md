## 问题1
轨迹服务器与RB规划器的关系：
RB规划器订阅了轨迹服务器的输出trajserver_output，发布了自己的输出rb_planner_output
轨迹服务器也订阅了rb_planner_output，发布trajserver_output
这比较奇怪，形成了循环结构

以下是rb_planner利用轨迹服务器的信息
def ts_callback(self, msg: TrajserverOutput):
    self.e_left_cur = msg.e_left_cur
    self.e_right_cur = msg.e_right_cur
    self.is_pit = msg.is_pit
    self.idx = msg.min_idx
只是部分信息

而轨迹服务器则利用了rb_planner输出的更多信息
所以应该是rb_planner->trajectory server的关系

# RB规划器解析
使用计时器进行触发
[安全检查]
保证self.state和self.race_control的存在和及时更新
```python
if not self.ready:
    self.ready = self.is_ready()
    self.check_input_timeout() # Call to see which input timeout is active
    return
        
if self.check_input_timeout():
    self.get_logger().error("Local planner input timeout", throttle_duration_sec=1.0)
    return
```


[没有接收到障碍物信息]
```python
max_velocity = self.race_control.max_velocity
e_ref = 0.0
```

[收到障碍车信息]
根据**RC的跟随命令**以及**是否在pitlane**使用两种策略
**1.跟车step**
找到前方的障碍车需要调用一些功能函数
1.1 如果前车静止且与本车相距35m以内，则
```python
v_max_follow = 0.0
```
1.2 其他情况速度根据位置间隔和速度间隔确定，公式如下：
（应该是一个经验公式）
```python
v_max_follow = 0.5*pos_error + 1.0*vel_error + closest_opp_front['v'] 
```
总体是一个大于前车车速的车速
最后经过clip处理使速度结果在[0,race_control.max_velocity]之间
e_ref = 0

**2.正常step**
首先对四辆车进行了初始化，分别是
closest_opp_front、min_ttc_opp_front、closest_opp_back、second_closest_opp_front

2.1 首先获取e_ref
划分了多个情况进行讨论：

使用道路边界和本车的安全车宽进行clip：
```python
e_ref = np.clip(e_ref, e_right + self.bound_safety, e_left - self.bound_safety)
```

2.2 然后获取v_max
if closest_opp_front['too_slow'] and closest_opp_front['dist'] < 100:不能超过前车速度+20
在跟随模式下，使用的速度策略与1.2相同

[输出部分]
输出max_velocity, e_ref两个值
输出时还记录了e_ref的历史(长度为10)，如果全部小于0.5则self.output.planner_coef = 1.0，否则self.output.planner_coef = 0.9

# TrajServer
## 节点运行流程
### 安全检查与Warmup
确保定位、RBPlanner决策、RC_control的接受没有超时
```python
st = time.time()
if not self.ready:
    #self.warmup()
    self.ready = self.is_ready()
    self.check_input_timeout() # Call to see which input timeout is active
    return
......
self.check_input_timeout()
```
warmup是采用全部为0的信号运行一次规划器的step
```python
if self.ready and not self.warmed_up:
    self.warmup()
    self.warmed_up = True
    self.trajserver.reset()
    return
```
### 设置最高车速
```python
self.set_v_max() # 获得 self.v_max 并传递给规划器
```
最高车速时RC_control赛事规则最高车速、RB_planner决策最高车速、以及制动最高车速的最小值
此外，还考虑了刹车预热模式。
开启刹车预热的条件：
1. 节点的功能开关`self.brake_warmup_mode`
2. 通过读取全局轨迹确定`self.trajserver.is_in_brake_warmup_zone()`
3. 在前两圈进行预热`self.trajserver.lap_count < self.brake_warmup_max_lap`
4. 不在pit中`not self.trajserver.is_pit`

### 墙内模式
采用wall_planner_output输出的侧向偏移和planner_coef
由lidar-processing包发出的follow_the_gap话题
判断条件：
1. 通过路径点的index区间确定`self.trajserver.is_in_tunnel()`
2. 存在墙内决策信号`self.wall_planner_output is not None`
3. 节点的墙内模式开关`self.enable_wall_tracker`

```python
trajserver_output = self.trajserver.step(curr_state, self.wall_planner_output.e_ref, self.wall_planner_output.planner_coef)
```

### 正常模式
采用rb_planner输出的侧向偏移和planner_coef
```python
trajserver_output = self.trajserver.step(curr_state, self.planner_output.e_ref, self.planner_output.planner_coef)
```

### 轨迹发布
将输出的dict转化为msg并发送至话题
```python
self.publish_output(trajserver_output, latency) 
```
在以下函数中判断是否进入Push-to-Pass模式（加速超车模式）
```python
self.publish_mode_request()
```
如果处于P2P区域并且没有蓝旗则激活加速超车模式
在self.p2p_active_end激活时间 15 s 内则保持加速超车模式
如果加速超车模式结束并且在冷却时间 5 s 内，则处于NONE_MODE

在本节点内可以使用self.disable_p2p禁用加速超车模式，最后将模式请求发送给'path_planner/mode_request'，由系统管理节点进行转发

## 规划器原理

功能函数：
1. `calc_min_dist(self, curr_state, x_traj, y_traj)`
根据当前状态和轨迹点序列，找到最近轨迹点的index。

2. `compute_lap_count(self, min_idx)`
根据最近轨迹点的index判断是否完成一圈比赛，输出圈数，在完成一圈的时候触发计时、录制。

3. `calc_rho_vector(self, curr_vx, min_idx, s)`
用于输出前方的曲率序列，曲率序列的距离间隔ds_target根据当前的速度确定。
