## 问题1
轨迹服务器与RB规划器的关系：
RB规划器订阅了轨迹服务器的输出trajserver_output，发布了自己的输出rb_planner_output
轨迹服务器也订阅了rb_planner_output，发布trajserver_output
这比较奇怪，形成了循环结构

以下是rb_planner利用轨迹服务器的信息
def ts_callback(self, msg: TrajserverOutput):
    self.e_left_cur = msg.e_left_cur
    self.e_right_cur = msg.e_right_cur
    self.is_pit = msg.is_pit
    self.idx = msg.min_idx
只是部分信息

而轨迹服务器则利用了rb_planner输出的更多信息
所以应该是rb_planner->trajectory server的关系

# RB规划器解析
使用计时器进行触发
[安全检查]
保证self.state和self.race_control的存在和及时更新
```python
if not self.ready:
    self.ready = self.is_ready()
    self.check_input_timeout() # Call to see which input timeout is active
    return
        
if self.check_input_timeout():
    self.get_logger().error("Local planner input timeout", throttle_duration_sec=1.0)
    return
```


[没有接收到障碍物信息]
```python
max_velocity = self.race_control.max_velocity
e_ref = 0.0
```

[收到障碍车信息]
根据**RC的跟随命令**以及**是否在pitlane**使用两种策略
**1.跟车step**
找到前方的障碍车需要调用一些功能函数
1.1 如果前车静止且与本车相距35m以内，则
```python
v_max_follow = 0.0
```
1.2 其他情况速度根据位置间隔和速度间隔确定，公式如下：
（应该是一个经验公式）
```python
v_max_follow = 0.5*pos_error + 1.0*vel_error + closest_opp_front['v'] 
```
总体是一个大于前车车速的车速
最后经过clip处理使速度结果在[0,race_control.max_velocity]之间
e_ref = 0

**2.正常step**
首先对四辆车进行了初始化，分别是
closest_opp_front、min_ttc_opp_front、closest_opp_back、second_closest_opp_front

2.1 首先获取e_ref
划分了多个情况进行讨论：

使用道路边界和本车的安全车宽进行clip：
```python
e_ref = np.clip(e_ref, e_right + self.bound_safety, e_left - self.bound_safety)
```

2.2 然后获取v_max
if closest_opp_front['too_slow'] and closest_opp_front['dist'] < 100:不能超过前车速度+20
在跟随模式下，使用的速度策略与1.2相同

[输出部分]
输出max_velocity, e_ref两个值
输出时还记录了e_ref的历史(长度为10)，如果全部小于0.5则self.output.planner_coef = 1.0，否则self.output.planner_coef = 0.9

# TrajServer
## 节点运行流程
### 安全检查与Warmup
确保定位、RBPlanner决策、RC_control的接受没有超时
```python
st = time.time()
if not self.ready:
    #self.warmup()
    self.ready = self.is_ready()
    self.check_input_timeout() # Call to see which input timeout is active
    return
......
self.check_input_timeout()
```
warmup是采用全部为0的信号运行一次规划器的step
```python
if self.ready and not self.warmed_up:
    self.warmup()
    self.warmed_up = True
    self.trajserver.reset()
    return
```
### 设置最高车速
```python
self.set_v_max() # 获得 self.v_max 并传递给规划器
```
最高车速时RC_control赛事规则最高车速、RB_planner决策最高车速、以及制动最高车速的最小值
此外，还考虑了刹车预热模式。
开启刹车预热的条件：
1. 节点的功能开关`self.brake_warmup_mode`
2. 通过读取全局轨迹确定`self.trajserver.is_in_brake_warmup_zone()`
3. 在前两圈进行预热`self.trajserver.lap_count < self.brake_warmup_max_lap`
4. 不在pit中`not self.trajserver.is_pit`

### 墙内模式
采用wall_planner_output输出的侧向偏移和planner_coef
由lidar-processing包发出的follow_the_gap话题
判断条件：
1. 通过路径点的index区间确定`self.trajserver.is_in_tunnel()`
2. 存在墙内决策信号`self.wall_planner_output is not None`
3. 节点的墙内模式开关`self.enable_wall_tracker`

```python
trajserver_output = self.trajserver.step(curr_state, self.wall_planner_output.e_ref, self.wall_planner_output.planner_coef)
```

### 正常模式
采用rb_planner输出的侧向偏移和planner_coef
```python
trajserver_output = self.trajserver.step(curr_state, self.planner_output.e_ref, self.planner_output.planner_coef)
```

### 轨迹发布
将输出的dict转化为msg并发送至话题
```python
self.publish_output(trajserver_output, latency) 
```
在以下函数中判断是否进入Push-to-Pass模式（加速超车模式）
```python
self.publish_mode_request()
```
如果处于P2P区域并且没有蓝旗则激活加速超车模式
在self.p2p_active_end激活时间 15 s 内则保持加速超车模式
如果加速超车模式结束并且在冷却时间 5 s 内，则处于NONE_MODE

在本节点内可以使用self.disable_p2p禁用加速超车模式，最后将模式请求发送给'path_planner/mode_request'，由系统管理节点进行转发

## 规划器原理
功能函数：
1. `calc_min_dist(self, curr_state, x_traj, y_traj)`
根据当前状态和轨迹点序列，找到最近轨迹点的index。
2. `compute_lap_count(self, min_idx)`
根据最近轨迹点的index判断是否完成一圈比赛，输出圈数，在完成一圈的时候触发计时、录制。
3. `calc_rho_vector(self, curr_vx, min_idx, s)`
用于输出前方的曲率序列，曲率序列的距离间隔ds_target根据当前的速度确定。

`step(self, curr_state, planner_e_ref, planner_coef)`过程：
### 侧向规划
侧向决策输入planner_e_ref
planner_e_ref向下取整获得e_ref_floored
如果self.e_ref_tar != e_ref_floored:也就是发生了决策变化
则self.e_ref_tar = e_ref_floored
并调用self.update_e_ref_vec(self.e_ref_tar, self.e_ref_sent, self.e_dot_ref_sent, curr_state['vx'])

否则判断如果self.min_idx < self.e_ref_update_idx
与上述情况相同

如果self.min_idx > self.e_ref_update_idx则无需进行self.update_e_ref_vec

self.sent_idx用于发送self.e_ref_sent和self.e_dot_ref_sent的index
self.sent_idx = self.min_idx - self.e_ref_update_idx = 0
并且clip到[0, self.preview_size_idx-1]区间下

进入update_e_ref_vec函数
merge_dist为换道距离，与速度相关
merge_dist = 2.0*max(vx, 10.0)

s, e_ref_pol, deds, curvature = 
generate_cubic_offset_poly(e_ref_sent, edotref_sent/max(vx, 10.0), e_ref_tar, 0.0, merge_dist )
generate_cubic_offset_poly(d0, d0_s, df, df_s, L=200.0)
本质上时使用三次多项式进行连接，参数包括a0～a3

输出
self.e_ref_vec[0:len(e_ref_pol)] = e_ref_pol
self.e_dot_vec[0:len(e_ref_pol)] = deds*max(vx, 10.0)
self.e_ref_sent = self.e_ref_vec[self.sent_idx]
self.e_dot_ref_sent = self.e_dot_vec[self.sent_idx] 

此外根据t_bound_horizon计算max_idx
并输出e_left_min，以及e_right_min

self.e = calc_lat_error(curr_state['x'], curr_state['y'], x_traj_cur, y_traj_cur, course_ref_cur)
计算self.e当前的l坐标

### 纵向规划
包络参数的使用 
```python
def update_gg_vec(self):
    for i in range(len(self.trajs)):
        n = len(self.trajs[i]['s'])
        self.trajs[i]['gg_vec'] = interpolate_gg_mult(n, self.corner_idx, self.gg_mult)
        self.trajs[i]['gg_acc_vec'] = interpolate_gg_mult(n, self.corner_idx, self.gg_mult + self.gg_acc_mult)
        self.trajs[i]['gg_dec_vec'] = interpolate_gg_mult(n, self.corner_idx, self.gg_mult + self.gg_dec_mult)
```
interpolate_gg_mult是进行线性插值
可以看到
self.trajs[i]['gg_vec']与参数gg_mult以及corner_idx组成的曲线
self.trajs[i]['gg_acc_vec']则增加了gg_acc_mult
self.trajs[i]['gg_dec_vec']则增加了gg_dec_mult

接下来时纵向规划函数
准备好
rho_vec_ds、gg_vec_for_ggv、gg_acc_vec_for_ggv、gg_acc_vec_for_ggv
curr_mult *= planner_coef给决策影响ggv提供了接口

如果进出pitlane还有额外的curr_mult *= 0.8
```python
vx_ref_vec_ds, ax_ref_vec_ds, vx_ref_adv, ax_ref_adv  = calc_vel_prof(
    vx_clipped, 
    self.trajs[self.current_traj]['ds']*10, 
    rho_vec_ds,
    self.vx_vec, 
    self.ax_max_vec, 
    self.dx_max_vec, 
    self.ay_max_vec, 
    self.combined_coef, 
    0.97*self.v_max, 
    self.Cd0, self.Cd1, self.Cd2, 
    self.time_adv_ax, 
    gg_vec_for_ggv, 
    gg_acc_vec_for_ggv, 
    gg_dec_vec_for_ggv
)
```
使用FB规划器获取vx_ref，然后基于速度曲线重新获取ax_ref
输出为vx_ref、ax_ref

前向后向计算过程
首先，获取当前车速的侧向加速度
```python
ay = v_ref[i] ** 2 * np.abs(rho[i])
```

获取参考车速下的gg图的ax、ay最大值标定点
```python
ax_max = np.interp(v_ref[i], vx_vec, ax_max_vec * gg_acc_vec[i])
ay_max = np.interp(v_ref[i], vx_vec, ay_max_vec * gg_vec[i])
```
ax_max_vec和ay_max_vec都是和速度平方呈现线性关系，线性系数为参数表中的ggv、ggv_acc、ggv_dec，这应该是空气动力学下压力引起的
```python
self.ax_max_vec = self.ax_max + self.ggv_acc*(self.vx_vec**2)
self.dx_max_vec = self.dec_max + self.ggv_dec*(self.vx_vec**2)
self.ay_max_vec = self.acc_max_lat + self.ggv*(self.vx_vec**2)
```
基于gg耦合关系，根据当前的ay获得最大的可行ax，其中combined_coef是一个形状的参数，目前=1.2
```python
`radicand = max (1.0 - min(ay / ay_max,1)** combined_coef, 1e-3)`
`ax_accel_lim = ax_max *  radicand ** (1.0 / combined_coef)`
```
加速时ax_accel_lim减去ax_drag，加速时ax_accel_lim加上ax_drag
```python
ax_drag = (Cd0 + Cd1 * v_ref[i] + Cd2 * v_ref[i]**2)
```



